#     <Step_3> From the table of contents, find the sections that cover the following topics. There shouldn't be more than 7-10 relevant sections. {section_finding_hint} </Step_3>
#     <Step_5> Verify that the section has information such as the listed here -> {verification_hint}. If none of the sections provide any relevant information, return NULL. </Step_5>
find_sections:
  description: >
    <GOAL>
    Examine the provided JSON structure representing a list of titles, labeled as "title_list".
    The user is looking for information about: "{topic}". Find the most relevant sections for given query.
    </GOAL>

    <STEPS>
    <Step_1> Determine which title in the list is most relevant to finding information about "{topic}" with respect to the zone code: "{zone_code}". Here is some additional information to help you: {title_finding_hint} </Step_1>
    <Step_2> Extract the detailed table of contents for the title you have chosen. You can use the table_of_contents_extractor_tool to do this. Remember, you have to pass in a Title, not a Chapter. </Step_2>
    <Step_3> For each of the following sub-topics, find all of the most relevant sections based on the table of contents that you have extracted. If you cannot find any relevant sections, return an empty array for that sub-topic. Do NOT miss any subtopics. There is also context for finding the sections for a subtopic listed.  <SUB-TOPICS> {section_finding_hint} </SUB-TOPICS> Note: it is rare that there is only zero or one sections for a subtopic, so do not be afraid to return multiple sections for a subtopic. It is better to return more sections than less. </Step_3>
    
    </STEPS>

    <JSON_STRUCTURE>
    List of titles:
    {title_list}
    </JSON_STRUCTURE>

    <HTML DOCUMENT ID>
    HTML document ID:
    {html_document_id}
    </HTML DOCUMENT ID>

  expected_output: >
    Return a JSON array of the sections you have extracted, ordered by relevance, including both the section 
    metadata and the complete extracted content.
    The output must follow this exact format:
    {topic} = [
      {
        "sub-topic": The sub-topic you are looking for,
        "section_number": an array of section numbers. Full section numbers, for example 151.039
        "section_title": an array of section titles,
        "relevance_score": an array of relevance scores from 1-10,
        "reason": an array of reasons for the relevance score,
      }
    ]
  agent: municipal_code_section_finder


extract_and_analyze_sections:
  description: >
    <GOAL>
    Extract the content of each section identified in the find_sections task and analyze them to answer the user's query about "{topic}" with respect to zone code "{zone_code}".
    </GOAL>

    <STEPS>
    <Step_1> Process the JSON output from the find_sections task. </Step_1>
    <LOOP> For each sub-topic in the output: 
    <Step_2> Iterate through all section numbers for the sub-topic. Use the section_extractor_tool to extract the full content of each section. </Step_2>
    <Step_3> For each extracted section, verify it contains relevant information based on this verification criteria: {verification_hint} </Step_3>
    <Step_4> If the section passes verification, analyze each sub-topic using the following process: {thought_process} </Step_4>
    </LOOP>
    <Step_5> Compile all your findings. Look at the example output listed below, and follow the format when returning your output. EXAMPLE OUTPUT: {examples} </Step_5>
    </STEPS>

    <HTML DOCUMENT ID>
    HTML document ID:
    {html_document_id}
    </HTML DOCUMENT ID>

  expected_output: >
      {expected_output}
  agent: municipal_code_section_analyst
  context: [find_sections]

    
    
